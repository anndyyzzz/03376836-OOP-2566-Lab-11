# 7.1
<img width="638" alt="Screenshot 2024-03-30 222408" src="https://github.com/anndyyzzz/03376836-OOP-2566-Lab-11/assets/144866059/78e9880f-e92f-4ca7-837a-d7096018d73c">

# 7.2
<img width="638" alt="Screenshot 2024-03-30 222423" src="https://github.com/anndyyzzz/03376836-OOP-2566-Lab-11/assets/144866059/3697ce36-3867-408b-b4ff-6464e631f338">

#### ในการทดลองนี้เรามีคลาส Base ที่มีเมทอด A() ที่ถูกประกาศเป็น virtual เพื่อให้สามารถโอเวอร์ไรด์ได้ และคลาส Derived_1 ที่โอเวอร์ไรด์เมทอด A() จาก Base และประกาศเมทอด A() ใหม่ (new) ใน Derived_2 โดยที่มันไม่ได้เชื่อมโยงกับการโอเวอร์ไรด์ใด ๆ ซึ่งเป็นไปตามแนวทางการเรียกใช้เมทอดของแต่ละอ็อบเจกต์ว่าถูกต้องตามลำดับของการสืบทอด ดังนั้นเมื่อเรียกใช้เมทอด A() ผ่านอ็อบเจกต์ b และ d1 จะเรียกใช้เมทอด A() ที่ถูกโอเวอร์ไรด์ใน Derived_1 และเมื่อเรียกใช้เมทอด A() ผ่านอ็อบเจกต์ d2 จะเรียกใช้เมทอด A() ที่ถูกประกาศใหม่ใน Derived_2 ทำให้เมทอด A() ใน Derived_2 ไม่ได้เรียกใช้เมทอด A() ใด ๆ ที่ถูกโอเวอร์ไรด์ไว้ก่อนหน้านี้ในโค้ด สรุปได้ว่า การใช้งานการโอเวอร์ไรด์และการประกาศเมทอดใหม่ใน C# ถูกจัดการอย่างถูกต้องและให้ผลลัพธ์ตามที่คาดหวัง
